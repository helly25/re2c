// Generated by re2zig
// re2zig $INPUT -o $OUTPUT

const std = @import("std");

// Expects a null-terminated string.
fn lex(yyinput: [:0]const u8) i32 {
    var yycursor: usize = 0;
    var yymarker: usize = 0;
    const yylimit: usize = yyinput.len; // points at the terminating null
    var count: i32 = 0;

    loop: while (true) {
        
    var yych: u8 = 0;
    var yystate: u32 = 0;
    yyl: while (true) {
        switch (yystate) {
            0 => {
                yych = yyinput[yycursor];
                switch (yych) {
                    0x20 => {
                        yycursor += 1;
                        yystate = 3;
                        continue :yyl;
                    },
                    0x27 => {
                        yycursor += 1;
                        yystate = 5;
                        continue :yyl;
                    },
                    else => {
                        if (yylimit <= yycursor) {
                            yystate = 10;
                            continue :yyl;
                        }
                        yycursor += 1;
                        yystate = 1;
                        continue :yyl;
                    },
                }
            },
            1 => {
                yystate = 2;
                continue :yyl;
            },
            2 => { return -1; },
            3 => {
                yych = yyinput[yycursor];
                switch (yych) {
                    0x20 => {
                        yycursor += 1;
                        yystate = 3;
                        continue :yyl;
                    },
                    else => {
                        yystate = 4;
                        continue :yyl;
                    },
                }
            },
            4 => { continue :loop; },
            5 => {
                yymarker = yycursor;
                yych = yyinput[yycursor];
                if (yych >= 0x01) {
                    yystate = 7;
                    continue :yyl;
                }
                if (yylimit <= yycursor) {
                    yystate = 2;
                    continue :yyl;
                }
                yycursor += 1;
                yystate = 6;
                continue :yyl;
            },
            6 => {
                yych = yyinput[yycursor];
                yystate = 7;
                continue :yyl;
            },
            7 => {
                switch (yych) {
                    0x27 => {
                        yycursor += 1;
                        yystate = 8;
                        continue :yyl;
                    },
                    0x5C => {
                        yycursor += 1;
                        yystate = 9;
                        continue :yyl;
                    },
                    else => {
                        if (yylimit <= yycursor) {
                            yystate = 11;
                            continue :yyl;
                        }
                        yycursor += 1;
                        yystate = 6;
                        continue :yyl;
                    },
                }
            },
            8 => { count += 1; continue :loop; },
            9 => {
                yych = yyinput[yycursor];
                if (yych <= 0x00) {
                    if (yylimit <= yycursor) {
                        yystate = 11;
                        continue :yyl;
                    }
                    yycursor += 1;
                    yystate = 6;
                    continue :yyl;
                }
                yycursor += 1;
                yystate = 6;
                continue :yyl;
            },
            10 => { return count; },
            11 => {
                yycursor = yymarker;
                yystate = 2;
                continue :yyl;
            },
            else => { @panic("internal lexer error"); },
        }
    }

    }
}

test {
    try std.testing.expectEqual(lex(""), 0);
    try std.testing.expectEqual(lex("'qu\x00tes' 'are' 'fine: \\'' "), 3);
    try std.testing.expectEqual(lex("'unterminated\\'"), -1);
}
