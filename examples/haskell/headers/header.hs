-- Generated by re2hs
{-# LANGUAGE RecordWildCards #-}
-- re2hs $INPUT -o $OUTPUT --header lexer/state.hs -i
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}
{-# LANGUAGE OverloadedStrings #-}

import Control.Monad (when)
import Data.ByteString (index)
import State




yy0 :: State -> Int
yy0 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x61 == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy0 State{..}
        _c | 0x62 == _c ->
            let _yyt1 = _yycursor in
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy2 State{..}
        _c | True ->
            let _yyt1 = _yycursor in
            yy1 State{..}

yy1 :: State -> Int
yy1 State{..} =
    let _tag = _yyt1 in
    _tag

yy2 :: State -> Int
yy2 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x62 == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy2 State{..}
        _c | True ->
            yy1 State{..}

lexer :: State -> Int
lexer State{..} =
    yy0 State{..}



main :: IO ()
main = do
    let s = State {
        _yyinput = "ab\0",
        _yycursor = 0,
        
_yyt1 = -1,
        _tag = 0}

    when (lexer s /= 1) $ error "failed!"
-- Generated by re2hs
{-# LANGUAGE RecordWildCards #-}

module State where

import Data.ByteString (ByteString)

data State = State {
    _yyinput :: !ByteString,
    _yycursor :: !Int,
    
_yyt1 :: !Int,
    _tag :: !Int
}
haskell/headers/header.re:28:20: warning: rule matches empty string [-Wmatch-empty-string]
