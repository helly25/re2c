// Generated by re2zig
// re2zig $INPUT -o $OUTPUT

const std = @import("std");



fn lex_tags(str: [:0]const u8) isize {
    var cur: isize = 0;
    var mar: isize = 0;
    var yyt1: isize = -1;

    var x: isize = 0;
    var y: isize = 0;

    
    var yych: u8 = 0;
    var yystate: u32 = 0;
    yyl: while (true) {
        switch (yystate) {
            0 => {
                mar = cur;
                yych = str[@intCast(cur)];
                switch (yych) {
                    0x62 => {
                        cur += 1;
                        yystate = 2;
                        continue :yyl;
                    },
                    else => {
                        yyt1 = -1;
                        yystate = 1;
                        continue :yyl;
                    },
                }
            },
            1 => {
                y = yyt1;
                x = yyt1;
                yyt1 = -1;
                if (x != yyt1) x += -1;
                return if (x == -1) -1 else y - x;
            },
            2 => {
                yych = str[@intCast(cur)];
                switch (yych) {
                    0x61 => {
                        cur += 1;
                        yystate = 4;
                        continue :yyl;
                    },
                    else => {
                        yystate = 3;
                        continue :yyl;
                    },
                }
            },
            3 => {
                cur = mar;
                yyt1 = -1;
                yystate = 1;
                continue :yyl;
            },
            4 => {
                yyt1 = cur;
                yystate = 1;
                continue :yyl;
            },
            else => { @panic("internal lexer error"); },
        }
    }

}

const yymaxnmatch = 3;


fn lex_captures(str: [:0]const u8) isize {
    var cur: isize = 0;
    var yyt1: isize = -1;
var yyt2: isize = -1;

    var yypmatch: [yymaxnmatch * 2]isize = undefined;
    var yynmatch: usize = 0;

    
    var yych: u8 = 0;
    var yystate: u32 = 0;
    yyl: while (true) {
        switch (yystate) {
            0 => {
                yych = str[@intCast(cur)];
                switch (yych) {
                    0x61 => {
                        yyt1 = cur;
                        cur += 1;
                        yystate = 2;
                        continue :yyl;
                    },
                    else => {
                        yyt1 = cur;
                        yyt2 = -1;
                        yystate = 1;
                        continue :yyl;
                    },
                }
            },
            1 => {
                yynmatch = 3;
                yypmatch[0] = yyt1;
                yypmatch[3] = yyt2;
                yypmatch[5] = yyt2;
                yypmatch[1] = cur;
                yypmatch[2] = yyt2;
                yyt2 = -1;
                if (yypmatch[2] != yyt2) yypmatch[2] += -1;
                yypmatch[4] = yypmatch[2];
                
            std.debug.assert(yynmatch == 3);
            return yypmatch[4];

            },
            2 => {
                yyt2 = cur;
                yystate = 1;
                continue :yyl;
            },
            else => { @panic("internal lexer error"); },
        }
    }

}

test {
    try std.testing.expectEqual(lex_tags(""), -1);
    try std.testing.expectEqual(lex_tags("ba"), 1);
    try std.testing.expectEqual(lex_captures(""), -1);
    try std.testing.expectEqual(lex_captures("a"), 0);
}
codegen/zig/nested_fixed_tags.re:26:25: warning: rule matches empty string [-Wmatch-empty-string]
codegen/zig/nested_fixed_tags.re:40:17: warning: rule matches empty string [-Wmatch-empty-string]
