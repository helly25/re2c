-- Generated by re2hs
{-# LANGUAGE RecordWildCards #-}
-- re2hs $INPUT -o $OUTPUT -i
{-# LANGUAGE OverloadedStrings #-}
{-# OPTIONS_GHC -Wno-unused-record-wildcards #-}

import Data.ByteString (ByteString, index)

data State = State {
    _yyinput :: ByteString,
    _yycursor :: Int,
    _yymarker :: Int
}


yy0 :: State -> Bool
yy0 State{..} =
    let yych = index _yyinput _yycursor in
    let __ = _yycursor + 1 in let _yycursor = __ in
    case yych of
        _c | 0x07 == _c ->
            yy3 State{..}
        _c | True ->
            yy1 State{..}

yy1 :: State -> Bool
yy1 State{..} =
    yy2 State{..}

yy2 :: State -> Bool
yy2 State{..} =
    False

yy3 :: State -> Bool
yy3 State{..} =
    let _yymarker = _yycursor in
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x08 == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy4 State{..}
        _c | True ->
            yy2 State{..}

yy4 :: State -> Bool
yy4 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x0C == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy6 State{..}
        _c | True ->
            yy5 State{..}

yy5 :: State -> Bool
yy5 State{..} =
    let _yycursor = _yymarker in
    yy2 State{..}

yy6 :: State -> Bool
yy6 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x0A == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy7 State{..}
        _c | True ->
            yy5 State{..}

yy7 :: State -> Bool
yy7 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x0D == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy8 State{..}
        _c | True ->
            yy5 State{..}

yy8 :: State -> Bool
yy8 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x09 == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy9 State{..}
        _c | True ->
            yy5 State{..}

yy9 :: State -> Bool
yy9 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x0B == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy10 State{..}
        _c | True ->
            yy5 State{..}

yy10 :: State -> Bool
yy10 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x5C == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy11 State{..}
        _c | True ->
            yy5 State{..}

yy11 :: State -> Bool
yy11 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x27 == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy12 State{..}
        _c | True ->
            yy5 State{..}

yy12 :: State -> Bool
yy12 State{..} =
    let yych = index _yyinput _yycursor in
    case yych of
        _c | 0x22 == _c ->
            let __ = _yycursor + 1 in let _yycursor = __ in
            yy13 State{..}
        _c | True ->
            yy5 State{..}

yy13 :: State -> Bool
yy13 State{..} =
    True

lexer :: State -> Bool
lexer State{..} =
    yy0 State{..}



main :: IO ()
main = do
    let st = State{
            _yyinput = "\x07\x08\x0c\x0a\x0d\x09\x0b\\'\"\0",
            _yycursor = 0,
            _yymarker = 0}
    case lexer st of
        True -> return ()
        False -> error "lexer failed!"
